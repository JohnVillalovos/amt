#!/usr/bin/env python

import argparse
import os
from pprint import pprint
import sys

import requests

import amt.client
import amt.hostdb
import amt.wsman


def main():
    parser = argparse.ArgumentParser(description="""
amtctrl lets you do hardware control on AMT enabled Intel machines. To
make it easier to use interactively, it operates as 2 things, a host
database to register hosts by ip or hostname, and then runs commands
by those aliases.""")

    parser.add_argument('-p', '--prompt-pass',
                        dest='prompt', action='store_true',
                        default=False,
                        help='Prompt for password, bypass database')
    subparsers = parser.add_subparsers(dest='command')

    parser_list = subparsers.add_parser('list', help='list all servers registered')

    parser_get = subparsers.add_parser('get', help='return info for a server')
    parser_get.add_argument('server', metavar='name', help='server name')

    parser_set = subparsers.add_parser('set', help='register a server')
    parser_set.add_argument('server', metavar='name', help='server name')
    parser_set.add_argument('host', metavar='host')
    parser_set.add_argument('passwd', metavar='passwd')
    parser_set.add_argument('-S', '--scheme', metavar='scheme', default='http', choices=['http', 'https'])
    parser_set.add_argument('-V', '--vncpasswd', metavar='vncpasswd')

    parser_rm = subparsers.add_parser('rm', help='unregister a server')
    parser_rm.add_argument('server', metavar='name', help='server name')

    parser_power = subparsers.add_parser('power', help='get/set power state')
    parser_power.add_argument('server', metavar='name', help='server name')
    parser_power.add_argument('state', choices=['on', 'off', 'reboot', 'reset', 'sleep', 'status'])

    parser_pxeboot = subparsers.add_parser('pxeboot', help='reboot the machine and pxeboot on the next reboot cycle')
    parser_pxeboot.add_argument('server', metavar='name', help='server name')

    parser_tls = subparsers.add_parser('tls', help='configure TLS')
    parser_tls.add_argument('server', metavar='name', help='server name')

    tls_subparsers = parser_tls.add_subparsers(dest='subcommand', required=True)

    parser_tls_list = tls_subparsers.add_parser('list', help='list certificates/keys')
    tls_list_subparsers = parser_tls_list.add_subparsers(dest='type', required=True)
    parser_tls_list_certs = tls_list_subparsers.add_parser('certs', help='certificates')
    parser_tls_list_keys = tls_list_subparsers.add_parser('keys', help='private keys')

    parser_tls_add = tls_subparsers.add_parser('add', help='add certificate/key')
    tls_add_subparsers = parser_tls_add.add_subparsers(dest='type', required=True)
    parser_tls_add_cert = tls_add_subparsers.add_parser('cert', help='certificate')
    parser_tls_add_cert.add_argument('-t', '--trusted', action='store_true', help='trusted root certificate')
    parser_tls_add_cert.add_argument('filename', metavar='filename', help='certificate file (PEM format)')
    parser_tls_add_key = tls_add_subparsers.add_parser('key', help='private key')
    parser_tls_add_key.add_argument('filename', metavar='filename', help='RSA private key file (PEM format)')

    parser_tls_rm = tls_subparsers.add_parser('rm', help='remove certificate/key')
    tls_rm_subparsers = parser_tls_rm.add_subparsers(dest='type', required=True)
    parser_tls_rm_cert = tls_rm_subparsers.add_parser('cert', help='certificate')
    parser_tls_rm_cert.add_argument('id', metavar='InstanceID', help='certificate InstanceID')
    parser_tls_rm_key = tls_rm_subparsers.add_parser('key', help='private key')
    parser_tls_rm_key.add_argument('id', metavar='InstanceID', help='private key InstanceID')

    parser_tls_generate = tls_subparsers.add_parser('generate', help='generate private key')
    parser_tls_generate.add_argument('bits', type=int, choices=[2048], help='RSA key size in bits')

    parser_tls_request = tls_subparsers.add_parser('request', help='sign certificate signing request')
    parser_tls_request.add_argument('filename', metavar='filename', help='unsigned certificate signing request file (PEM format)')
    parser_tls_request.add_argument('id', metavar='InstanceID', help='private key InstanceID')

    parser_tls_enable = tls_subparsers.add_parser('enable', help='enable TLS')
    parser_tls_enable.add_argument('-l', '--local', action='store_true', help='Configure local connections only')
    parser_tls_enable.add_argument('-r', '--remote', action='store_true', help='Configure remote connections only')
    parser_tls_enable.add_argument('-p', '--plaintext', action='store_true', help='Allow plaintext connections')
    parser_tls_enable.add_argument('-m', '--mutual', action='store_true', help='Require mutual authentication')
    parser_tls_enable.add_argument('-c', '--cn', default=[], action='append', help='Allowed common names')
    parser_tls_enable.add_argument('id', metavar='InstanceID', help='certificate InstanceID')

    parser_tls_status = tls_subparsers.add_parser('status', help='get TLS settings')

    parser_tls_disable = tls_subparsers.add_parser('disable', help='disable TLS')
    parser_tls_disable.add_argument('-l', '--local', action='store_true', help='Configure local connections only')
    parser_tls_disable.add_argument('-r', '--remote', action='store_true', help='Configure remote connections only')

    parser_uuid = subparsers.add_parser('uuid', help='get machine uuid')
    parser_uuid.add_argument('server', metavar='name', help='server name')

    parser_vnc = subparsers.add_parser('vnc', help='get/set vnc state')
    parser_vnc.add_argument('server', metavar='name', help='server name')
    parser_vnc.add_argument('state', choices=['start', 'stop', 'status'])

    args = parser.parse_args()
    db = amt.hostdb.HostDB()

    if args.command not in [None, 'list', 'get', 'set', 'rm']:
        if args.prompt:
            host = args.server
            if sys.stdin.isatty():
                from getpass import getpass
                passwd = getpass()
            else:
                passwd = sys.stdin.readline().rstrip('\r\n')
        else:
            server = db.get_server(args.server)
            if not server:
                print('Server %s not found in hostdb' % args.server)
                return 1
            host = server['host']
            passwd = server['passwd']
            scheme = server['scheme']
            vncpasswd = server['vncpasswd']
            client = amt.client.Client(host, passwd, vncpasswd=vncpasswd,
                                       protocol=scheme)

    try:
        if args.command == 'list':
            db.list_servers()
        elif args.command == 'get':
            server = db.get_server(args.server)
            print('%s => %s' % (args.server, server['host']))
        elif args.command == 'set':
            db.set_server(args.server, args.host, args.passwd,
                             args.vncpasswd, scheme=args.scheme)
        elif args.command == 'rm':
            db.rm_server(args.server)
        elif args.command == 'power':
            if args.state == 'on':
                client.power_on()
            elif args.state == 'off':
                client.power_off()
            elif args.state == 'reboot':
                client.power_cycle()
            elif args.state == 'reset':
                client.power_cycle_hard()
            elif args.state == 'sleep':
                client.power_sleep()
            elif args.state == 'hibernate':
                client.power_hibernate()
            else:
                print(amt.wsman.friendly_power_state(client.power_status()))
        elif args.command == 'pxeboot':
            client.pxe_next_boot()
            client.power_cycle()
        elif args.command == 'tls':
            if args.subcommand == 'list':
                if args.type == 'certs':
                    for cert in client.get_tls_certs():
                        pprint(cert)
                elif args.type == 'keys':
                    for key in client.get_tls_keys():
                        pprint(key)
            elif args.subcommand == 'add':
                if args.type == 'cert':
                    for cert in client.add_tls_cert(args.filename, args.trusted):
                        pprint(cert)
                elif args.type == 'key':
                    for key in client.add_tls_key(args.filename):
                        pprint(key)
            elif args.subcommand == 'rm':
                if args.type == 'cert':
                    print(client.remove_tls_cert(args.id))
                elif args.type == 'key':
                    print(client.remove_tls_key(args.id))
            elif args.subcommand == 'generate':
                print(client.generate_tls_key(args.bits))
            elif args.subcommand == 'request':
                # This needs a "null signed" CSR containing the public key only
                # but as of v1.1.1, there is no "openssl" command to do this.
                # (The CA does not require a CSR to create a certificate but it
                # is required by all public CAs to verify ownership of the key.)
                for request in client.sign_tls_csr(args.filename, args.id):
                    pprint(request)
            elif args.subcommand == 'enable':
                if client.remote:
                    print("remote", client.configure_remote_tls(args.id, args.cn)) # TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
                    print("remote", client.enable_remote_tls(args.plaintext, args.mutual)) # TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
                if client.local:
                    print("local", client.configure_local_tls(args.id)) # TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
                    print("local", client.enable_local_tls(args.plaintext)) # TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
                client.commit_setup_changes()
            elif args.subcommand == 'status':
                pprint(client.get_tls_status()) # TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
            elif args.subcommand == 'disable':
                if client.remote:
                    print("remote", client.disable_remote_tls()) # TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
                if client.local:
                    print("local", client.disable_local_tls()) # TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
                client.commit_setup_changes()
        elif args.command == 'uuid':
            print(client.get_uuid())
        elif args.command == 'vnc':
            if args.state == 'start':
                if client.enable_vnc():
                    print('VNC enabled on port 5900 with AMT password')
            elif args.state == 'stop':
                if client.disable_vnc():
                    print('VNC disabled')
            else:
                print(client.vnc_status())
        else:
            parser.error("No command specified")
    except requests.exceptions.HTTPError as e:
        print('Error: %s' % e)


if __name__ == '__main__':
    sys.exit(main())
